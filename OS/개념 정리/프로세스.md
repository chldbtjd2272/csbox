# 프로세스

## 01. 프로세스의 정의
**프로세스** 란, 프로그램이 실행되는 상태를 의미한다.   
- 하나의 프로그램에서 여러 개의 프로세스 생성 가능
- 코드, 스택, 자료로 구성
- PCB(Process Control Block)로 대표
- 작업 단위로서의 의미도 존재
  
[![image.png](https://s33.postimg.cc/vo5phoodr/image.png)](https://postimg.cc/image/6i4raun3f/)  

프로그램과 달리 프로세스는 메모리에 주소 공간을 갖는 능동적인 개체  
- 텍스트(코드) : 프로세스가 실행하는 코드 저장
- 데이터(정적 변수) : 프로세스 실행 중에 할당받는 영역, 전역 또는 정적 변수 저장
- 실행 스택(Stack) : 호출된 프로시저(함수)의 복귀 주소와 지역 변수 등의 일시적인 데이터를 저장하는 영역
- 실행 힙(Heap) : 텍스트(코드) 영역과는 별도로 유지되는 자유 영역

### 프로세스의 상태

[![image.png](https://s33.postimg.cc/gth43bzbj/image.png)](https://postimg.cc/image/7lovmms97/)  

**프로세스** 는, 실행되면서 자신의 상태가 시시각각 변한다.

- 신규(new) - 프로세스 생성중
    - 프로세스가 시작되어 그 프로세스를 위한 각종 자료 구조는 생성되었지만 아직 메모리 획득을 승인받지 못한 상태
- 준비(ready) - 프로세스가 설정되어 대기중
    - 프로세스가 CPU만 보유하면 당장 명령을 실행할 수 있지만 CPI를 할당받지 못한 상태
- 실행(running) - 프로세스가 실행하는 중
    - 프로세스가 CPU를 보유하고 기계어 명령을 실행하고 있는 상태
- 대기(blocked, wait, sleep) - 프로세스가 이벤트 발생을 대기중
    - 프로세스에게 CPU를 주어도 당장 명령을 실행할 수 없는 상태
- 종료(terminated) - 프로세스가 실행을 종료
    - 프로세스가 종료되었으나 운영 체제가 그 프로세스와 관련된 자료 구조를 완전히 정리하지 못한 상태
  
### PCB (프로세스 제어 블록)

**PCB**란, 운영 체제가 시스템 내의 프로세스들을 관리하기 위해 프로세스당 유지하는 정보들을 담는 커널 내의 자료구조를 뜻한다.  

[![image.png](https://s33.postimg.cc/clmbum86n/image.png)](https://postimg.cc/image/5iegf02qz/)  

구성
- 프로세스 상태(state)
    - CPU를 할당해도 되는지 여부를 결정하기 위해 필요
- 프로그램 카운터(program counter)
    - 다음에 수행할 명령의 위치를 가리킴
- CPU 레지스터들
    - CPU 연산을 위해 현 시점에 레지스터에 어떤 값을 저장하고 있는지를 나타냄
- CPU 스케쥴링 정보
    - 프로세스의 CPU 스케줄링에 필요한 정보
- 메모리 관리 정보
    - 메모리 할당을 위해 필요한 정보
- 입출력 상태 정보
- 자원 사용 정보
    - 사용자에게 자원 사용 요금을 계산해 청구하는 등의 용도

## 02. 프로세스 스케쥴링

**스케줄링 큐** 란? 스케줄링을 위해서 PCB들이 연결되는 큐

큐의 종류
- 작업 큐
    - 시스템 내의 모든 프로세스를 관리하기 위한 큐
    - 프로세스의 상태와 무관하게 현재 시스템 내에 있는 모든 프로세스가 작업 큐에 속함
- 준비 큐
    - CPU를 할당받고 실행되기 위해 기다리고 있는 프로세스의 집합
- 장치 큐
    - 각각의 장치마다 서비스를 기다리며 줄 서 있는 프로세스의 큐

### 스케쥴러의 종류

**스케줄러** 란? 어떤 프로세스에게 자원을 할당할지를 결정하는 운영 체제 커널의 모듈을 지칭

종류
- 단기(CPU) 스케줄러
    - 준비 상태의 프로세스들 중에서 어떤 프로세스를 다음 번에 실행 상태로 만들 것인지 결정하는 스케줄러
    - 준비 큐에 있는 여러 프로세스들 중에 어떠한 프로세스에게 CPU를 할당할 것인가를 단기 스케줄러가 결정
- 장기(작업) 스케줄러
    - 어떤 프로세스를 준비 큐에 삽입할지를 결정하는 역할
    - 프로세스에게 메모리를 할당하는 문제에 관여
    - 메모리에 동시에 올라가 있는 프로세스의 수를 조절하는 역할


| 단기 스케줄러                                                       | 장기 스케줄러                                                                  |
|---------------------------------------------------------------------|--------------------------------------------------------------------------------|
| ms 이하의 시간 단위로 매우 빈번히 호출</br>수행 속도가 충분히 빨라야 함 | 복수십 초 내지 수 분 단위로 가끔 호출 </br>느린 속도도 허용 |

[![image.jpg](https://s33.postimg.cc/lfnc5xkn3/image.jpg)](https://postimg.cc/image/xhiq02tvf/)  

- 중기 스케줄러
    - 너무 많은 프로세스에게 메모리를 할당해 시스템의 성능이 저하되는 경우 이를 해결하기 위해 메모리에 적재된 프로세스의 수를 동적으로 조절하기 위해 추가된 스케줄러
    - 메모리에 올라와 있는 프로세스 중 일부를 선정해 이들로부터 메모리를 통째로 빼앗아 그 내용을 디스크의 스왑 영역에 저장 :: 스왑 아웃(swap out)
    - 스왑 아웃 0 순위 프로세스 : 봉쇄 상태 프로세스들
        - why? 당장 CPU를 획득할 가능성이 없기 때문에 메모리를 보유하고 있는 것 또한 큰 의미가 없음



### 문맥 교환

**문맥 교환** 이란, 하나의 사용자 프로세스로부터 다른 사용자 프로세스로 CPU의 제어권이 이양되는 과정을 뜻함.  
- CPU를 다른 프로세스로 전환하기 위해 이전의 프로세스 상태를 보관하고 새로운 프로세스의 보관된 상태를 적재하는 작업
- 전환하는 동안 어떤 유용한 작업도 불가능
  
[![image.jpg](https://s33.postimg.cc/wrzxo46b3/image.jpg)](https://postimg.cc/image/muowv1yp7/)  

문맥 교환 시간
- 하드웨어 지원에 의해 크게 결정 : 기억 장치의 속도, 레지스터 수, 특권 명령 등
- 운영 체제가 복잡할 수록 문맥 교환에 더 많은 작업 요구

## 03. 프로세스에 대한 연산
프로세스의 생성
- 운영체제가 프롯스 전부를 생성 X
- 시스템이 부팅된 후 최초의 프로세스는 운영체제가 직접 생성 -> 그 다음부터는 이미 존재하는 프로세스가 다른 프로세스를 복제 생성
- **부모 프로세스** : 프로세스를 생성한 프로세스
- **자식 프로세스** : 새롭게 생성된 프로세스
- 프로세스, 족보와 같은 계층 生
- UNIX의 fork 명령

- 자원 공유
    - 부모와 자식 프로세스가 모든 자원을 공유
    - 자식 프로세스가 부모 프로세스 자원의 일부분을 사용
- 실행
    - 부모 프로세스가 자식 프로세스와 함께 실행
    - 부모 프로세스가 모든 자식 프로세스가 끝날 때까지 대기
- 주소 공간
    - 자식은 부모 프로세스의 복사판
    - 자식 프로세스는 별도의 프로그램을 적재

프로세스의 종료  
- 프로세스, 마지막 문장의 실행을 끝내고 종료하면 운영체제에 프로세스 삭제를 요청(exit)
    - 프로세스, 부모 프로세스에게 자료를 돌려줄 수 있음(wait)
    - 프로세스의 자원은 운영 체제가 회수

- 부모 프로세스는 자식 프로세스 종료시킬 수 있음(abort)
    - 부모가 종료되면 자식 프로세스도 강제로 종료 가능

[![image.jpg](https://s33.postimg.cc/dq0ctdsv3/image.jpg)](https://postimg.cc/image/kggu2tg0r/)  

프로세스 중단(일시 정지)과 재시작
- 시스템에 장애 발생시 실행 중인 프로세스 잠시 중단 -> 시스템이 기능을 회복했을 때 다시 재시작
- 처리할 일 너무 多 시스템 부담 大 -> 프로세스 몇 개를 중단했다가 시스템이 다시 정상 상태로 돌아왔을 때 재시작

## 04. IPC (프로세스간 통신)
프로세스들간의 관계는 독립적이거나 또는 협동적
- 독립적인 경우
    - 주어진 초기 치에 대해서 항상 같은 결과 도출
    - 다른 프로세스의 영향을 받지 않음
- 협동적인 경우
    - 다른 프로세스에게 영향을 주거나 받음

협동 프로세스가 필요한 이유? **정보 공유, 연산 속도 증가, 모듈성**

협동 프로세스는 프로세스간 통신과 동기화 메커니즘이 필요하다.

**공유 메모리 시스템** 이란? 통신을 위해서 프로세스들 사이에 구축한 공유 메모리 영역
- 일반적으로 OS, 한 프로세스가 다른 프로세스의 메모리에 접근하는 것 금지
- 둘 이상의 프로세스가 위의 제약조건을 제거하는 것에 동의
- 여러 개의 프로세스들이 동시에 동일한 위치에 쓰이지 않도록 관리 ( 임계 영역 문제 )

생산자 / 소비자 문제 (생산자 / 소비자 프로세스) :: 공유 메모리를 이용한 협동 프로세스의 대표적인 예
- 생산자 프로세스 -> 정보 생산
- 소비자 프로세스 -> 정보 소비
- 인쇄 프로그램/프린터 구동기, 컴파일러/어셈블러, 어셈블러/적재기

생산자/소비자 프로세스들의 병행 실행을 위해 버퍼 필요
- 생산자의 속도와 소비자의 속도는 서로 독립적 -> 버퍼 필요
- 생산자와 소비자는 같은 버퍼에 접근 -> 동시에 사용 불가
- 생산자가 채워진 버퍼를 채우거나, 소비자가 빈 버퍼에서 꺼낼 때 문제 발생

**IPC(Interprocess Communication)** 이란?
- 프로세스들간의 통신과 동기화 제공
- 메세지 전달 시스템
    - 공유 변수들을 자주 거칠 필요 없이 프로세스들이 서로 통신

기본 구조
- send(message) / receive(message) 의 두 가지 연산 제공
- 통신 연결을 설정하고 send / receive 를 통해 메세지 교환

직접 통신
- 메세지 전송/수신 시 통신의 전송자/수신자 이름 명시
    - Send(P. message), Receive(Q. message)
- 연결이 자동으로 이루어짐
- 각 쌍에 정확히 하나의 연결이 존재

간접 통신
- 메세지를 메일 박스로 송신하고 이것으로부터 수신
- 각 메일박스, 고유의 id 를 가짐
- 연결은 두 프로세스 이상과 연관
- 각 프로세스 사이의 메일 박스마다 하나의 연결이 존재

통신의 동기화
- 봉쇄형(blocking) = synchoronous
- 비봉쇄형(non-blocking) = asynchronous
- 봉쇄형 또는 비봉쇄형 조합 가능

메세지 큐(메세지 버퍼)
- 자체 안에 임시로 메세지들을 내재하는 공간
- 일반적으로 용량이 유한적