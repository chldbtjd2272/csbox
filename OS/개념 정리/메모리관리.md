# 메모리관리
## 01. 배경
다중 프로그래밍에서 주기억 장치를 여러 프로그램이 공유하기 위해 주기억 장치 관리 기법이 필요하다.  
#### 주기억 장치 관리의 선택 요인
- 다중 프로그래밍의 정도
    - 몇 개의 프로그램을 메모리에 적재할 것인가?
    - 이것이 과다하면 이는 어떻게 탐지하고 이에 대해서 취할 수 있는 조치는 무엇인가?
    - 어떤 프로그램을 어느 부분에 적재할 것인가?
    - 만약에 들어갈 자리가 없다면?
    - 프로그램이 어느 부분에 들어갈지 모르므로 주소의 사상은 어떻게?

#### 주소 바인딩
[![2018-08-16_5.41.24.png](https://s22.postimg.cc/5kn56ueox/2018-08-16_5.41.24.png)](https://postimg.cc/image/5kn56ueot/)  
프로그램의 명령어와 데이터를 기억 장치 주소 공간으로 할당  
기억 장치 공간에서의 바인딩 시점
- 컴파일 시간 바인딩
    - 프로그램의 메모리 저장 위치가 고정
- 적재 시간 바인딩
    - 재배치 가능 심볼로 유지
    - 프로그램이 메모리에 적재되는 시기에 메모리 위치 결정
- 실행 시간 바인딩
    - 실행 중간에 메모리 저장 위치가 MMU에 의해서 결정
    - 실행 중 위치 변경 가능
  
**논리 주소(논리 주소 공간)** 이란? CPU가 생성하는 주소 : 변위 or (기준 레지스터 + 변위)  
**물리 주소(물리 주소 공간)** 이란? 기억 장치에 나타나는 주소  
컴파일 시간 바인딩과 적재 시간 바인딩 : 논리 주소 = 물리 주소 
실행 시간 바인딩 : 논리 주소 =/= 물리 주소 (MMU가 변경)  
  
**기억장치 관리기(MMU)**란? 논리 주소(가상 주소)의 물리 주소 사상을 수행하는 하드웨어다.
- 재배치 레지스터라고 불리기도 한다
- 실행 시간에 주소 바인딩
  
동적 적재(Dynamic Loading)
- 루틴이 호출될 때까지 기억 장치 내에 적재하지 않음
- 사용되지 않는 루틴은 적재되지 않음 -> 효율적 메모리 사용
- 각 루틴은 호출되기 전까지 디스크에서 재배치 가능한 형태로 대기

동적 연결(Dynamic Linking)
- 적재 및 연결이 실행 시점까지 지연
- 대개 시스템 / 공유(shared) 라이브러리에서 사용
- 라이브러리 루틴 변경 시 유용

중첩(Overlays)
- 허용된 메모리 크기보다 큰 프로그램을 실행할 때, 해결법은?
    - 상주부분과 오버레이 부분으로 구분하여 사용
- 오버레이 영역
    - 필요에 따라서 프로그램을 적재하여 실행
    - 필요 없으면 -> 다른 프로그램으로 교체
- 프로그래머가 오버레이 구조를 설계하고 프로그램 해야함

## 02. 교체(swapping)
**교체**란? 할당 시간량이 소진되거나 높은 우선 순위 프로세스가 도착할 때, 한 프로세스를 디스크로 보내고 새 프로세스를 불러들이는 동작을 말한다.
- 라운드로빈 또는 우선 순위 스케줄링에서 사용됨
- 많은 시스템에서 사용됨
    - UNIX, Linux, Windows

고려사항
- 교체시간 : 디스크의 성능에 의해 좌우, 디스크 내에 별도 장소를 지정
- 메모리 사용량 : 교체되는 메모리 양이 교체 시간에 영향
- 교체 대상 : 아무 일도 하지 않는 프로세스

메모리 관리 기법 분류
- 연속 메모리 할당 방식
    - 프로그램(프로세스)를 적재하는 과정에서 연속적으로 메모리를 할당
    - 직접 배치, 중첩(오버레이), 분할 기법 등이 해당
        - 고정 분할 기법 : 메모리를 고정된 크기로 분할하여 프로세스에 제공
        - 동적(가변) 분할 기법 : 각 프로세스의 크기에 따라 메모리를 분할하는 방식

분산 메모리 할당 방식
- 프로세스가 페이지나 세그먼테이션 등의 단위로 보조기억장치에 적재되어 있다가, 프로세스의 요구에 의해 메모리의 여러 영역에 할당
- 현재의 가상 메모리 관리 기법으로 발전됨

## 03. 연속 메모리 할당
프로그램(프로세스) 를 적재하는 과정에서 연속적으로 메모리를 할당  
메모리를 분할하여 여러 개의 프로그램을 수용하여 다중 프로그래밍 가능  
메모리 분할
- 운영체제 부분과 사용자 부분 둘로 나눔
- 사용자 부분에 여러 개의 사용자 프로그램이 있는 경우만 고려

고정 분할
- 기억 장치를 고정된 크기로 분할
- 다중 프로그래밍 정도는 분할의 수에 의해 제한
- 운영체제는 분할 간 보호
    - 한계 및 재배치 레지스터에 의한 지원

- 고정 분할에서의 단편화(Fragmentation)
    - 사용자 작업의 크기가 지정된 분할에 정확히 맞지 않거나, 분할이 너무 작아서 대기 중인 작업 중 하나도 맞는 것이 없는 상태
    - 단편화, 메모리 구성과 관계없이 모든 컴퓨터 시스템에서 발생
    - 단편화, 작업 스케줄러와 분할의 크기에 의해 좌우

가변 불할
- 고정된 경계를 없애고 각 작업이 필요한 만큼 메모리를 할당
- 프로세스가 도착할 때, 충분한 크기의 빈 블록을 찾아서 할당하고 나머지를 사용 가능한 부분으로 남김

메모리 배치 기법
- 할당 가능한 메모리 공간들 중에서 어느 곳에 배치할 지 결정
- 최초 적합(First-fit), 최상 적합(Best-fit), 최악 적합(Worst-Fit)
    - 최초 적합 기법
        - 사용가능공간 리스트에서 충분히 큰 첫 번째 공백 분할 공간에 할당
        - 검색은 fast 공간 활용률이 떨어짐
    - 최상 적합 기법
        - 들어갈 수 있는 충분한 공간들 중에서 가장 작은 크기의 공간에 할당
        - 사용가능공간에 대한 지속적인 정렬과정이 필요, 비효율적 (정렬 x 시엔 전 리스트 검색)
        - 사용가능공간 이용률은 향상, 할당되는 과정에서 많은 시간 소요
    - 최악 적합 기법
        - 작업을 가장 큰 사용가능공간에 할당
        - 공간이 크기 순서로 정렬되어 있지 않을 시 전 리스트를 검색

**단편화(fragmentation)**
- 외부 단편화 : 프로세스의 메모리 할당 요청을 만족할 수 있는, 여러 조각들로 나누어진 가용 기억 공간
    - 외부 단편화 문제 해결 방법 중 하나 : 압축
        - **압축**?
            - 메모리의 여러 영역들을 옮겨 모든 작은 빈 공간들을 연속된 하나의 큰 빈 공간으로 만드는 작업
            - 재배치가 실행시간에 동적으로 이루어지는 경우에만 가능
            - 장점 : 새로운 작업에 할당 가능
            - 단점 : 압축할 동안 시스템은 모든 일 정지, 재배치 정보 관리 필요
- 내부 단편화 : 할당된 기억 공간이 요청된 기억 공간보다 더 클 때, 남는 부분

버디 시스템
- 커널 메모리 할당에 적용
    - 다양한 크기의 자료 구조 사용 : 내부 단편화 문제 커짐
    - 물리 메모리에 직접 접근하는 특정 하드웨어 장치 : 연속적인 메모리 할당 필요
- 동작원리
    - 요청된 크기가 버퍼보다 작으면, 버퍼를 동일한 크기의 2개의 버디로 나눔
    - 가능할 때마다 인접한 자유로운 버퍼들을 합치는 과정 반복

## 04. 페이징 기법
**페이징 기법** : 분산 메모리 할당 방식
- 프로그램을 페이지라는 고정 크기 단위로 나누어 분산 적재
- 메모리 영역도 프레임이라는 고정 크기로 분리하여 관리

페이징 시스템 하드웨어
- 논리 페이지의 물리 메모리(페이지) 프레임 적재 과정을 수행하는 페이지 시스템 하드웨어 구조

페이지 스케줄링
- 프로세스 수행을 위해 준비 큐에 도착하면, 프로세스의 크기는 페이지 단위로 표현
- 장기 스케줄러는 빈 페이지 프레임 리스트를 유지하고 프레임을 프로세스에 할당

페이지 크기
- 페이지 크기(프레임 크기)는 하드웨어에 의해 결정
- 일반적으로 2의 누승(512bytes ~ 16Kbytes)
- 단순한 내부 단편화 현상만 생각하면 크기가 작은 페이지가 바람직
- 페이지 테이블 유지 부담은 페이지 크기를 증가시킴으로써 감소

페이지 테이블
- 활동 중인 각 작업은 페이지 테이블 가짐
- 레지스터로 구성되거나 메인 메모리의 일부로 배정

페이지 테이블의 구현
- 전용 레지스터의 집합 ( 페이지 테이블이 작은 경우 )
- 페이지 테이블을 주기억 장치에 유지
    - 위치 : CPU 내의 페이지 테이블 기준 레지스터
    - 기억 장치 위치에 접근하는 데 많은 시간 소요
        - 한 워드에 접근하기 위해 두 번의 기억장치 접근 필요

TLB 사용
- 특수한 작은 하드웨어 캐시 : 빠른 연관 메모리
- 탐색은 빠르지만 하드웨어가 고가

페이지 보호 및 공유
- 페이지 보호
    - 페이지 테이블에 보호용 비트 추가 (타탕 비트)
    - 페이지 단위로 판독 적용, 판독/기록 전용, 실행 전용 등의 보호 지정

공유 페이지
- 시분할 환경에서 중요한 공통된 코드를 프로세스들 사이에서 공유
- 모든 프로세스의 논리 주소 공간에서 같은 위치
- 읽기 전용(재진입) 코드
    - 편집기, 컴파일러들, 윈도우 시스템

페이징 기법 장점
- 공유 페이지의 이용
- 외부 단편화 제거(내부 단편화는 발생)
- 압축 기능 제거

페이징 기법 단점
- 페이징 사상을 위한 하드웨어 준비로 가격이 상승함
- 속도 저하

## 05. 페이지 테이블의 구조
계층적 페이지 테이블 : 가중 계층 페이지 테이블
- 가상주소 공간이 커질 수록 페이지 테이블의 크기도 증가
    - 메모리에 큰 적재 공간 요구
- 논리 주소 공간을 여러 개의 페이지 테이블로 나누어서 저장
- 단순한 방법 : 2 단계 페이지 테이블

해시형 페이지 테이블
- 32 bits보다 큰 주소 공간(64bits)을 다룰 때 사용
    - 7번의 메모리 잡근을 사용하는 다단계 페이징의 문제점 개선
    - 가상 주소 공간에 비해 실 사용 주 메모리 용량 작음
    - 해시 함수를 사용하여 실제 메모리 주소를 빨리 찾기 위한 방법

역 페이지 테이블
- 시스템 상에 하나의 페이지 테이블만 존재
    - 실제 메모리의 각 페이지에 대해 하나의 엔트리
    - 프로세스 당 페이지 테이블을 가지는 단점 제거
- 페이지 참조할 때 테이블을 찾는 데 필요한 시간은 증가
- 페이지 공유는 어려움
  
변환 우선참조 버퍼(TLB)
- 페이지 테이블의 항목들을 위한 특별한 캐시 사용
- 전체 페이지 테이블 중 가장 최근에 참조한 페이지 일부만 저장
- 가상 주소가 주어지면 먼저 변환 우선참조 버퍼 조사, 페이지 p 찾기
    - 원하는 페이지 테이블의 항목이 있다 -> 프레임 번호를 조사하여 메모리 주소 작성
    - 원하는 페이지 테이블 항목이 없다 -> 프로세스, 페이지 번호를 이용하여 해당 페이지 테이블 항목 조사

다중 계층 페이징
- 페이지 테이블을 n-단계 계층구조로 구성
    - 가상주소공간의 크기가 커질 수록 페이지 테이블의 크기 증가
    - 페이지 테이블을 유지하기 위해 발생하는 메모리 낭비 최소화


## 06. 세그먼테이션 기법
**세그먼테이션** 기법이란? 사용자 관점을 지원하는 기억 장치 관리 방법
- 세그먼트 : 메모리의 가변적인 단위
- 프로그램은 세그먼트들의 집합

[![2018-08-17_12.14.14.png](https://s33.postimg.cc/q7s6vk36n/2018-08-17_12.14.14.png)](https://postimg.cc/image/6pxjfm68r/)  
  
논리 주소 = <세그먼트 번호, 오프셋> 으로 구성  
세그먼트 테이블 : 가변 크기 세그먼트 위치에 저장
- 기준 : 세그먼트 시작 물리 주소
- 한계 : 세그먼트의 길이

할당
- 최상 적합 / 최초 적합 등의 동적 기억 장치 할당 기법 사용
- 외부 단편화 문제 발생

세그먼테이션의 보호와 공유
- 보호
    - 명령어로 구성된 세그먼트는 읽기 또는 수행 전용으로 정의
    - 세그먼트 테이블의 각 항목에 대한 보호 비트를 추가
- 공유
    - 프로그램 코드 및 데이터의 공유

페이지화된 세그먼테이션
- 페이징과 세그먼테이션의 결합된 구조
- 페이징
    - 내부 단편화 현상, 동일한 크기의 공간 관리로 메모리를 효율적으로 사용
- 세그먼트
    - 외부 단편화 현상, 공유와 보호의 지원이 편리
- 외부 단편화 문제를 제거하면서 할당 과정을 쉽게 해결