## 선택 정렬

선택 정렬은 이름에 맞게 현재 위치에 들어갈 값을 찾아 정렬하는 배열이다.
현재 위치에 저장될 값의 크기가 작냐 크냐에 따라 최소 선택 정렬과 최대 선택 정렬로 구분 할 수 있다.

1. 정렬 되지 않은 인덱스의 맨 앞에서 부터, 이를 포함한 그 이후의 배열값 중 가장 작은 값을 찾아간다.
2. 가장 작은값을 찾으면, 그 값을 현재 인덱스의 값과 바꿔준다.
3.  다음 인덱스에서 위 과정을 반복하게 해준다.

선택정렬은 배열이 어떻게 되어있던지간에 전체 비교를 진행하므로 시간 복잡도는 O(n^2)이다.
공간복잡도는 O(n)

![](https://t1.daumcdn.net/cfile/tistory/244575335708D49925)




## 삽입 정렬
삽입 정렬은 현재 위치에서, 그 이하의 배열들을 비교하여 자신이 들어갈 위치를 찾아, 그 위치에 삽입하는 배열 알고리즘이다.

1. 삽입 정렬은 두 번째 인덱스부터 시작한다. 현재 인덱스는 별도의 변수에 저장해주고, 비교 인덱스를 현재 인덱스 -1로 잡는다.
2. 별도로 저장해 둔 삽입을 위한 변수와, 비교 인덱스의 배열 값을 비교한다.
3. 삽입 변수의 값이 더 작으면 현재 인덱스로 비교 인덱스의 값을 저장해주고, 비교 인덱스를 -1하여 비교를 반복한다.
4. 만약 삽입 변수가 더 크면, 비교 인덱스 +1에 삽입 변수를 저장한다.

이 정렬 알고리즘은 최악의 경우엔 O(n^2)이지만 정렬되어 있는 경우에는 O(n)이다.
공간복잡도 O(N)
![](https://t1.daumcdn.net/cfile/tistory/2379163F5708D7B003)




## 버블 정렬

버블 정렬은 매번 연속된 두개 인덱스를 비교하여, 정한 기준의 값을 뒤로 넘겨 정렬하는 방법이다.
오름차순으로 정렬하고자 할 경우, 비교시마다 큰 값이 뒤로 이동하여, 1바퀴 돌 시 가장 큰 값이 맨 뒤에 저장된다. 맨 마지막에는 비교하는 수들 중 가장 큰 값이 저장 되기 때문에, (전체 배열의 크기 - 현재까지 순환한 바퀴 수) 만큼만 반복해 주면 된다.

1. 삽입 정렬은 두 번째 인덱스부터 시작한다. 현재 인덱스 값과, 바로 이전의 인덱스 값을 비교한다.
2. 만약 이전 인덱스가 더 크면, 현재 인덱스와 바꿔준다.
3. 현재 인덱스가 더 크면, 교환하지 않고 다음 두 연속된 배열값을 비교한다.
4. 이를 (전체 배열의 크기 - 현재까지 순환한 바퀴 수) 만큼 반복한다.


이 정렬 알고리즘은 1부터 비교를 시작하여, n-1개, n-2개,...,1개씩 비교를 반복하며, 선택 정렬과 같이 배열이 어떻게 되어있던지간에 전체 비교를 진행하므로 시간복잡도는 O(n^2)이다.
공간복잡도는 O(n)이다.
![](https://t1.daumcdn.net/cfile/tistory/261CE2435708D7C217)