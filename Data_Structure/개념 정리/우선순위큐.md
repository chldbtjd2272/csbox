# 우선순위큐
#### 우선순위큐의 개념
**우선순위큐** : 우선순위를 가진 항목들을 저장하는 큐
- FIFO 순서가 아니라 우선순위가 높은 데이터가 먼저 나가게 됨
- 가장 일반적인 큐 : 스택이나 FIFO 큐를 우선순위큐로 구현가능

#### 우선순위큐 ADT
~~~
객체 : n개의 element형의 우선순위를 가진 요소들의 모임
연산 : 
    - create() :: 우선순위큐를 생성
    - init(q) :: 우선순위큐 q를 초기화
    - is_empty(q) :: 우선순위큐 q가 비어있는지를 검사
    - is_full(q) :: 우선순위큐 q가 가득 찼는가 검사
    - insert(q, x) :: 우선순위큐 q에 요소 x를 추가
    - delete(q) :: 우선순위큐로부터 가장 우선순위가 높은 요소를 삭제하고 해당 요소를 반환
    - find(q) :: 우선순위가 가장 높은 요소를 반환
~~~

#### 우선순위큐 구현방법
[![2018-08-17_11.24.50.png](https://s22.postimg.cc/ixmly6281/2018-08-17_11.24.50.png)](https://postimg.cc/image/cwox13flp/)  
- 배열을 이용한 우선순위큐
- 연결리스트를 이용한 우선순위큐
- 히프를 이용한 우선순위큐

#### 힙이란?
- 노드들이 저장하고 있는 키들이 다음과 같은 식을 만족하는 완전이진트리
- 최대힙
    - key(부모노드) >= key(자식노드)
- 최소힙
    - key(부모노드) <= key(자식노드)
- N개의 노드를 가지고 있는 힙의 높이 O(logN)
- 마지막 레벨 h를 제외하고는 각 레벨 i에 2ⁱ⁻¹개의 노드 존재
- 구현방법 : 배열 ( 완전이진트리이므로 각 노드에 번호를 붙일 수 있음 )
    - 왼쪽 자식의 인덱스 = 부모의 인덱스*2
    - 오른쪽 자식의 인덱스 = 부모의 인덱스*2 + 1
    - 부모의 인덱스 = 자식의 인덱스 / 2
  
  ##### 힙 삽입 연산
  - 회사에서 신입 사원이 들어오면 일단 말단 위치에 -> 능력을 봐서 위로 승진
  - 1. 힙에 새로운 요소 진입 -> 새로운 노드, 힙의 마지막 노드에 이어서 삽입
  - 2. 삽입 후, 새로운 노드를 부모 노드들과 교환해서 힙 성질 만족

##### upheap 연산
- 새로운 키 k 삽입연산 후 힙의 성질이 만족되지 않아 삽입된 노드로부터 루트까지의 경로에 있는 노드들을 k와 비교, 교환함으로써 힙의 성질 복원

##### 힙 삭제 연산
- 최대힙에서의 삭제 : 가장 큰 키값을 가진 노드 삭제 (루트노드)
    - 1. 루트노드를 삭제한다
    - 2. 마지막 노드를 루트노드로 이동한다
    - 3. 루트에서부터 단말노드까지의 경로에 있는 노드들을 교환하여 힙 성질을 만족

##### 힙의 복잡도
- 삽입 연산에서 최악의 경우 : O(logN)
- 삭제 연산에서 최악의 경우 : O(logN)

##### 힙정렬
1. 정렬해야 할 n개의 요소들을 최대 힙에 삽입
2. 한 번에 하나씩 요소를 힙에서 삭제하여 저장
3. 삭제되는 요소들, 값이 증가되는 순서(최소 힙의 경우)
4. 하나의 요소를 힙에 삽입하거나 삭제할 때 시간이 O(logN) 만큼 소요 & 요소의 개수가 n개 -> 전체적으로 O(nlogN)
5. 힙정렬이 최대로 유용한 경우 : 전체 자료를 정렬하는 것이 아니라 가장 큰 값 몇 개만 필요할 때