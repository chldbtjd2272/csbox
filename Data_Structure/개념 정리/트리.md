# 트리
#### 트리의 개념
**트리** : 계층적인 구조를 나타내는 자료구조
- 리스트, 스탹, 큐 등은 선형 구조
- 트리, 부모-자식 관계의 노드들로 이루어짐
- 응용분야
    - 계층적인 조직 표현
    - 컴퓨터 디스크의 디렉토리 구조
    - 인공지능에서의 결정트리

#### 용어
[![2018-08-17_10.22.51.png](https://s22.postimg.cc/tpfkzyv01/2018-08-17_10.22.51.png)](https://postimg.cc/image/i0blc0419/)
- 노드 : 트리의 구성요소
- 루트 : 부모가 없는 노드(A)
- 서브트리 : 하나의 노드와 그 노드들의 자손들로 이루어진 트리
- 단말노드 : 자식이 없는 노드 (A, B, C, D)
- 비단말노드 : 적어도 하나의 자식을 가지는 노드 (E, F, G, H, I, J)
- 자식, 부모, 형제, 조상, 자손 노드 : 인간의 관계와 동일
- 레벨 : 트리의 각 층의 번호
- 높이 : 트리의 최대 레벨 (3)
- 차수 : 노드가 가지고 있는 자식 노드의 개수

#### 트리의 종류
[![2018-08-17_10.24.10.png](https://s22.postimg.cc/ybbp8cj41/2018-08-17_10.24.10.png)](https://postimg.cc/image/sae0b9whp/)
- 트리
    - 이진트리
    - 일반트리

##### 이진 트리
- 모든 노드가 2개의 서브 트리를 가지고 있는 트리
    - 서브트리는 공집합일 수 있음
- 이진트리의 노드에는 최대 2개까지의 자식 노드가 존재
- 모든 노드의 차수가 2 이하 -> 구현하기에 편리
- 이진트리, 서브트리간의 순서가 존재
- 검증
    - 공집합이거나
    - 루트와 왼쪽 서브트리, 오른쪽 서브트리로 구성된 노드들의 유한집합으로 정의
    - 이진트리의 서브트리들은 모두 이진트리
- 성질
    - 노드의 개수가 n개면 간선의 개수는 n-1개
    - 높이가 h일 경우 최소 h개의 노드를 가지며 최대 2ʰ-1의 노드를 가짐
    - n개의 노드를 가지는 이진트리의 높이
        - 최대 n
        - 최소 log₂(n+1)
- 분류
    - 포화 이진 트리
        - 트리의 각 레벨에 노드가 꽉 차있는 이진트리
        - 전체 노드의 개수 = 2ᵏ-1
    - 완전 이진 트리
        - [![2018-08-17_10.41.23.png](https://s22.postimg.cc/l9ulvou81/2018-08-17_10.41.23.png)](https://postimg.cc/image/yqrkek4jh/)
        - 레벨 1부터 k-1까지는 노드가 모두 채워져 있고 마지막 레벨 k에서는 왼쪽부터 오른쪽으로 노드가 순서대로 채워져있는 이진트리
    - 기타 이진 트리

#### 배열을 이용하는 방법
배열 표현법
- 모든 이진트리를 포화이진트리라고 가정하고 각 노드에 번호를 붙여서 그 번호를 배열의 인덱스로 삼아 노드의 데이터를 배열에 저장하는 방법

부모와 자식 인덱스 관계
- 노드 i의 부모 노드 인덱스 = i/2
- 노드 i의 왼쪽 자식 노드 인덱스 = 2i
- 노드 i의 오른쪽 자식 노드 인덱스 = 2i+1

#### 포인터를 이용하는 방법
링크 표현법
- 포인터를 이용하여 부모노드가 자식노드를 가리키게 하는 방법
- 노드 : 구조체
- 링크 : 포인터

~~~
typedef struct TreeNode {
    int data;
    struct TreeNode *left, *right;
} TreeNode;
~~~

#### 이진트리의 순회
**순회** : 트리의 노드들을 체계적으로 방문하는 것
- 3가지의 기본적인 순회방법
    - [![2018-08-17_10.47.18.png](https://s22.postimg.cc/6dw2oe8m9/2018-08-17_10.47.18.png)](https://postimg.cc/image/8v7tvnsil/)
    - 전위순회 : VLR
        - [![2018-08-17_10.48.51.png](https://s22.postimg.cc/5odacb30h/2018-08-17_10.48.51.png)](https://postimg.cc/image/5odacb30d/)
        - 자손노드보다 루트노드를 먼저 방문
    - 중위순회 : LVR
        - [![2018-08-17_10.49.13.png](https://s22.postimg.cc/fmy8y7rpd/2018-08-17_10.49.13.png)](https://postimg.cc/image/5pn855k3h/)
        - 왼쪽자손, 루트, 오른쪽자손 순으로 방문
    - 후위순회 : LRV
        - [![2018-08-17_10.49.34.png](https://s22.postimg.cc/v8fki6qsx/2018-08-17_10.49.34.png)](https://postimg.cc/image/p7hvl446l/)
        - 루트노드보다 자손을 먼저 방문
    - 레벨순회
        - 각 노드를 레벨 순으로 검사하는 순회 방법
        - 큐를 사용하는 순회법
  
#### 수식트리
**수식트리** : 산술식을 트리형태로 표현한 것
- 비단말노드 : 연산자
- 단말노드 : 피연산자
- 수식트리계산
    - 후위순회를 사용
    - 서브트리의 값을 순환호출로 계산

#### 스레드 이진 트리
- 이진트리의 NULL 링크를 이용하여 순환호출 없이도 트리의 노드들을 순회
- NULL 링크에 중위 순회시에 후속 노드인 중위 후속자를 저장시켜 놓은 트리가 스레드 이진 트리

#### 이진탐색트리
- 탐색작업을 효율적으로 하기위한 자료구조
- key(왼쪽서브트리) <= key(루트노드) <= key(오른쪽서브트리)
- 이진탐색을 중위순회 -> 오름차순으로 정렬된 값 얻을 수 있음

##### 탐색 연산
- 비교한 결과가 같으면 탐색 종료
- 비교한 결과가 주어진 키 값이 루트 노드의 키값보다 작다 -> 루트 노드의 왼쪽 자식을 기준으로 다시 시작
- 비교한 결과가 주어진 키 값이 루트 노드의 키값보다 크다 -> 루트 노드의 오른쪽 자식을 기준으로 다시 시작

~~~
// 순환
TreeNode *search(TreeNode *node, int key) {
    if (node == NULL) return NULL;
    if (key == node->key) return node;
    else if (key < node->key)
        return search(node->left, key);
    else
        return search(node->right, key);
}

// 반복
TreeNode *search(TreeNode *node, int key) {
    while(node != NULL) {
        if (key == node->key) return node;
        else if (key < node->key)
            node = node->left;
        else
            node = node->right;
    }
    return NULL;
}
~~~

##### 이진탐색트리에서의 삽입연산
- 원소를 삽입하기 위해서 먼저 탐색을 수행
- 탐색에 실패한 위치 -> 새로운 노드를 삽입하는 위치

##### 이진탐색트리에서의 삭제연산
- 1. 삭제하려는 노드가 단말 노드일 경우
    - 단말노드의 부모노드를 찾아서 연결을 끊는다
- 2. 삭제하려는 노드가 하나의 왼쪽이나 오른쪽 서브트리 중 하나만 가지고 있는 경우
    - 삭제되는 노드가 왼쪽이나 오른쪽 서브 트리 중 하나만 갖고 있을 때, 그 노드는 삭제하고 서브 트리는 부모 노드에 붙여준다
- 3. 삭제하려는 노드가 두 개의 서브 트리를 모두 가지고 있는 경우
    - 삭제노드와 가장 비슷한 값을 가진 노드를 삭제노드 위치로 가져온다

##### 이진탐색트리의 성능분석
- 이진탐색트리에서의 탐색, 삽입, 삭제 연산의 시간복잡도는 트리의 높이를 h라고 했을 때 h에 비례한다
- 최선의 경우
    - 이진 트리가 균형적으로 생성되어 있는 경우
        - h = log₂n
- 최악의 경우
    - 한쪽으로 치우친 경사이진트리의 경우
        - h = n
    - 순차탐색과 시간복잡도가 같음